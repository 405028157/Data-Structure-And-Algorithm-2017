线性表的插入操作（数组表示）：
1.表要没有满 2.插入的位置要合法 3.记得更新Last，让它仍指向最后一个元素。
4.在第i个位置上插入一个值为X的元素，数组的起始下标为0，所以第i个位置的下标为i - 1。

线性表的删除操作（数组表示）：
1.表不能为空 2.删除的位置要合法 3.记得更新Last，让他仍指向最后一个元素。 

顺序表可以用数组实现，也可以用链表实现

求表长：
int Length ( List PtrL )
{ List p = PtrL; /* p指向表的第一个结点*/
  int j = 0;
  while ( p ) {
    p = p->Next;
    j++; /* 当前p指向的是第 j 个结点*/
  }
  return j;
}
Ptrl是不是链表的第一个结点？（感觉不是）

按序号查找: FindKth
List FindKth( int K, List PtrL )
{ List p = PtrL;
  int i = 1;
  while (p !=NULL && i < K ){
    p = p->Next;
    i++;
  }
  if ( i == K ) return p;
  /* 找到第K个，返回指针 */
  else return NULL;
  /* 否则返回空 */
  
  //思考为什么不能直接简化为 return p; 像下面的按值查找一样
}

按值查找: 
List Find( ElementType X, List PtrL )
{
  List p = PtrL;
  while ( p!=NULL && p->Data != X )
    p = p->Next;
  return p; //如果发现 p != NULL， 则说明找到了
}

插入操作：
1.插入在第一个位置需要单独处理，插入到最后不需要（程序可以正常解决）
2.异常处理

删除：
1.记得释放被删除的结点（通过malloc分配的空间可以用free释放掉）
2.先把要删除的结点赋给一个指针变量，不然完成“删除”操作后，没有办法free掉旧的结点
3.删除表的第一个结点单独处理，删除最后一个结点不需要单独处理
4.异常处理

广义表
多重链表（十字链表——一种典型的多重链表）

中缀表达式、后缀表达式、前缀表达式

堆栈（Stack）：具有一定操作约束的线性表，只在一端（栈顶，Top）做插入、删除
1.入栈（Push）2.出栈（Pop）3.后入先出：Last In First Out（LIFO）

栈的顺序存储实现：
1.如果栈为空，top为-1

Push：

一个数组实现两个堆栈
一种比较聪明的方法是使这两个栈分别从数组的两头开始向中间生长；当两个栈的栈顶指针相遇时，表示两个栈都满了。
S.Top1 = -1;
S.Top2 = MaxSize; //表示堆栈为空

栈顶指针Top应该在链表的哪一头？

建立堆栈（注意只是建立头结点，并不代表任何一个元素）
Stack CreateStack()
{ /* 构建一个堆栈的头结点，返回指针 */
  Stack S;
  S =(Stack)malloc(sizeof(struct SNode));
  S->Next = NULL;
  return S;
}

堆栈用链表实现，PUSH操作不需要判断满不满，但是Pop需要判断空不空
后缀表达式：
1.当前运算符比栈顶的运算符优先级高时，把当前运算符push进去（压栈），反之，把栈顶运算符pop出来，再把当前运算符push进去
2.同一个运算符号在堆栈里面和外面不一定相同，比如括号，在堆栈外面优先级很高，但在堆栈里面优先级最低，遇到右括号之后再把
  运算符取出，直到取到堆栈里面的左括号
3.运算符同一优先级时，运算顺序从左到右

中缀表达式如何转换为后缀表达式标准描述：
从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理。
① 运算数：直接输出；
② 左括号：压入堆栈；
③ 右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）；
④ 运算符：
•若优先级大于栈顶运算符时，则把它压栈；
•若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，
 然后将该运算符压栈；
⑤ 若各对象处理完毕，则把堆栈中存留的运算符一并输出。
中缀表达式如何转换为后缀表达式

堆栈的其他应用：
 函数调用及递归实现（保存调用之前变量的状态以及调用回来之后准备要执行的程序的地址）
 深度优先搜索
 回溯算法
。。。













